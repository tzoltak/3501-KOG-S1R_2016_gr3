---
title: "Statystyka I z R<br/>Warsztat 2. Struktury danych; parametry rozkładu zmiennej"
author: "Tomasz Żółtak"
date: "10 października 2016"
output:
  html_document:
    css: ../styles.css
    toc: TRUE
    toc_depth: 3
---

Na dzisiejszych zajęciach zapoznamy się z jedną z podstawowch struktur danych w języku R -- wektorami. Poznamy też spsób użycia pętli *for* i instrukcji earunkowych *if-else*. W dalszej części zajęć będziemy wykorzystywać je, aby przypomnieć sobie sposób obliczania podstawowych parametrów (statystyk opisowych) zmiennej statystycznej.

# Podstawowe struktury danych w R - wektory

Wektor w R to ciąg elementów tego samego typu - typowo liczb, ale mogą to być również wartości logiczne lub tekst.

## Tworzenie wektorów

Poniżej znajdują się przykłady pokazujące różne sposoby tworzenia wektorów.

Zacznijmy od funkcji `vector()`. W kodzie poniżej tworzymy dwudziestoelementowy wektor typu *numeric* i przypisujemy go do obiektu `x`.

```{r comment="", prompt=TRUE}
x = vector(mode = "numeric", length = 20)
```

Zobaczmy, jak wygląda nasz wektor. Możemy poprosić R o wyświetlenie danego obiektu po prostu wpisując jego nazwę w konsolę. Możemy też użyć funkcji `str()` aby zobaczyć syntetyczny opis struktury daneg obiektu (w zasadzie te same informacje możemy uzyskać przeglądając zakładkę *Environment* w prawym górnym panelu RStudio).

```{r comment="", prompt=TRUE, collapse=TRUE}
x
str(x)
```

Warto zwrócić uwagę, że funkcja `vector()` domyślnie przypisała elementom wektora wartości - w przypadku typu *numeric* są to 0.

Dowiedzmy się czegoś więcej o funkcji `vector()` - zapoznajmy się z jej dokumentacją:

```{r eval=FALSE, comment="", prompt=TRUE}
?vector
```

---

#### Zadanie:

Zapoznaj się z sekcją *Details* dokumentacji funkcji `vector()` i dowiedz się, jakie są inne typy (*mode*) wektorów, które można utworzyć. W bloku kodu poniżej wpisz wywołania tej funkcji, tworzące wektory pozostałych typów. Jakie są wartości domyślne elementów wektorów poszczególnych typów?

```{r comment="", prompt=TRUE, collapse=TRUE}
# to jest miejsce na Twój kod
```

---

W praktyce do tworzenia wektorów zwykle wykorzystuje się inne funkcje, które pozwalają od razu przypisać jego kolejnym elementom wartości, które chcemy.

Funkcja `seq()` pozwala wygenerować sekwencję (ciąg arytmetyczny) liczb:

```{r comment="", prompt=TRUE, collapse=TRUE}
seq(from = 1, to = 10, by = 1)
seq(from = -3.5, to = 1.5, by = 0.5)
seq(from = 0.2, by = 0.2, length.out = 5)
```

Ciąg kolejnych liczb całkowitych najłatwiej jednak wygenerować korzystając z operatora `:`.

```{r comment="", prompt=TRUE, collapse=TRUE}
1:10
20:0
```

Zupełnie dowolne wartości elementom wektora możemy przypisać używając funkcji `c()` (*de facto* łączy ona ze sobą kilka wektorów w jeden dłuższy):

```{r comment="", prompt=TRUE, collapse=TRUE}
x = c(1, -5, 7, 20, 154)
x
y = c(0:-5, seq(from = 0.2, by = 0.2, length.out = 5), 154)
y
```

Przydatna bywa też funkcja `rep()`, która pozwala nam utworzyć wektor składający się z powtórzeń wartości.

```{r comment="", prompt=TRUE, collapse=TRUE}
rep(1, 10)
rep(c(1, 2), 3)
rep(c(1, 2), each = 3)
```

Elementom wektora możemy też nadać nazwy korzystając z funkcji `c()`, albo z funkcji `setNames()`.

```{r comment="", prompt=TRUE, collapse=TRUE}
c("1. element" = 1, "2. element" = 2, "3. element" = 3)
x = 1:3
x = setNames(x, c("1. element", "2. element", "3. element"))
x
names(x)
```

Długość (liczbę elementów) wektora możemy sprawdzić przy pomocy funkcji `length()`.

```{r comment="", prompt=TRUE, collapse=TRUE}
x
length(x)
```

---

#### Zadanie:

Korzystając z poznanych funkcji w bloku kodu poniżej utwórz wektory o wartościach podanych w komentarzach.

```{r comment="", prompt=TRUE, collapse=TRUE}
# wektor zawierający sekwencję liczb całkowitych od 64 do 128

# wektor zawierający ciąg liczb: 1, -5, 2.5, 8

# wektor zawierający ciąg liczb 4, 5, 6, 4, 5, 6, 1, 2, 3, 4, 5

```

---

## Operacje na wektorach

Ważną cechą wektorów jest to, że operacje wykonywane są domyślnie na wszystkich jego elementach:

```{r comment="", prompt=TRUE, collapse=TRUE}
x = 1:5
x
x + 1
x / 2
```

Jeśli operację wykonujemy na dwóch wektorach o tej samej liczbie elementów, to zostanie ona przeprowadzona na odpowiednich elementach każdego z nich:

```{r comment="", prompt=TRUE, collapse=TRUE}
x + x
x / x
x * c(0, 1, 0, 1, 0)
```

A co, jeśli wektory nie są tej samej długości?

```{r comment="", prompt=TRUE, collapse=TRUE}
y = rep(0, 5)
y + 1:3
```

Jeśli dwa wektory są różnej długości, ten który jest krótszy zostanie wydłużony poprzez powtarzanie (i, jeśli liczba elementów dłuższego wektora nie jest wielkrotnością jego długości, następnie przycięty), a potem wykonana zostanie żądana operacja. W sytuacji takiej otrzymamy jednak ostrzeżenie, że stało się coś potencjalnie niepożądanego. **Generalnie, powinniśmy unikać takich sytaucji.**

## Operacje arytmetyczne

  1. Do wykonywania podstawowych operacji arytmetycznych służą operatory `+`, `-`, `*`, `/`. Operator `^` oznacza potęgowanie (i pierwiastkowanie - przez podnoszenie do niecałkowitych potęg z przedziału (0;1) ).
  2. Moduł liczby pozwala obliczyć funkcja `abs()`.
  3. Zaokrąglanie: funkcje `floor()`, `ceiling()`, `trunc()`, `round()` (p. ich dokumentacja).
  4. Część całkowita z dzielenia: operator `%/%`.
  5. Eksponensa i logarytm: funkcje `exp()` i `log()`.

```{r comment="", prompt=TRUE, collapse=TRUE}
x = -2:2 + 0.2
x
abs(x)
trunc(x)
y = 1:5
y / 2
y %/% 2
trunc(y / 2)
```

## Sortowanie

Aby posortować elementy wektora można użyć funkcji `sort()`:

```{r comment="", prompt=TRUE, collapse=TRUE}
z = c(8, 7, 2, 4, 15, 0)
z
sort(z)
```

## Porównywanie wartości wektorów

Możemy też oczywiście porównywać ze sobą wartości wektorów używając operatorów `>`, `<`, `>=`, `<=` i `==` (pamiętajmy, że pojedynczy znak równości to operator przypisania). W efekcie przeprowadzenia takiego porównania otrzymamy wektor wartości logicznych.

```{r comment="", prompt=TRUE, collapse=TRUE}
x
x >= 2
x == 2
x == 1:5
```

Na wektorach logicznych możemy też wykonywać operacje *lub*, *i*, stosując operatory odpowiednio: `|`, `&`, a także operację *albo-albo* stosując funkcję `xor()`.

```{r comment="", prompt=TRUE, collapse=TRUE}
y = c(TRUE, TRUE, FALSE, FALSE)
z = c(TRUE, FALSE, TRUE, FALSE)
y | z
y & z
xor(y, z)
```

## Wybieranie elementów wektora

```{r comment="", prompt=TRUE, collapse=TRUE}
x = 1:100
```

Czasem chemy użyć tylko niektórych elementów wektora. Wybieranie ich umożliwia operato `[]`. Można to zrobić na kilka sposobów:

  1. Podając wektor numerów elementów które chcemy wybrać:
```{r comment="", prompt=TRUE, collapse=TRUE}
x[1:10]
x[c(1, 100, 50)]
```
  2. Podając wektor liczb przeciwnych do numerów elementów, którcyh **nie** chcemy wybrać:
```{r comment="", prompt=TRUE, collapse=TRUE}
x[-(11:100)]
x[-(rep(2:9, 10) + 10 * rep(0:9, each = 8))]
```
  3. Podając wektor wartości logicznych o liczbie elementów równej wektorowi, którego elementy wybieramy (typowo wynik zastosowania jakiejś operacji porównania):
```{r comment="", prompt=TRUE, collapse=TRUE}
(1:4)[c(TRUE, FALSE, FALSE, TRUE)]
x[(x > 50 & x <= 55) | x < 10]
```

Warto zwrócić uwagę, że pierwszy z opisanych sposobów posiada pewną własność, której nie mają dwa pozostałe - pozwala zwrócić elementy wektora w dowolnej kolejności, potencjalnie innej niż ta, w której występują one w wektorze, z którego je wybieramy.


---

#### Zadanie:

W bloku kodu poniżej zapisz polecenia, które będą wybierały opisane w komentarzach elementy wektora.

```{r comment="", prompt=TRUE, collapse=TRUE}
y = 1:20
# wybierz elementy: trzeci, ósmy i dwunasty

# wybierz elementy: wszystkie z wyjątkiem siódmego , piętnastego i osiemnastego

# wybierz elementy: szestnasty, ósmy, piąty i siódmy (dokładnie w tej kolejności)

# wybierz elementy: mniejsze od piętnastu, ale nie mniejsze niż osiem

# wybierz elementy: wszystkie liczby nieparzyste
#   (inspiracji może poszukać w sekcji "Operacje arytmetyczne")

```

---

## Wektory jako zbiory wartości

Wektory możemy też traktować jako zbiory wartości i wykonywać na nich operacje takie jak suma, część wspólna czy różnica.

```{r comment="", prompt=TRUE, collapse=TRUE}
x = 1:10
y = 6:15
union(x, y)
intersect(x, y)
setdiff(x, y)
setdiff(y, x)
```

# Pętla for()

Pętla `for` w R działa zupełnie inaczej, niż w języku C (i pochodnych) oraz językach o podobnej do C składni (np. Javie)! Działa jednak bardzo podobnie do tego, jak w Pythonie. W wywołaniu pętli wskazujemy nazwę zmiennej, której kolejno (w kolejnych obiegach pętli) nadawane będą wartości kolejnych elementów zadanego wektora. Pętla zostanie (co do zasady) wykonana zostanie więc tyle razy, ile elementów ma podany wektor. Przykładowo:

```{r comment="", prompt=TRUE, collapse=TRUE}
for (i in 1:5) {
  print(i)
}
```

W każdym obiegu pętli zmienna `i` była jednoelementowym wektorem - kolejnymi wartościami z sekwencji `1:5`. Aby wyświetlić na konsoli jej wartości musieliśmy w tym przypadku użyć funkcji `print()` - pętla sama z siebie nie zwraca nic na konsolę.

W ramach pętli możemy też oczywiście wykorzystać inne zmiene, zdefiniowane poza pętlą. Poniższy kod oblicza sumę wartości wektora `x` (dla weryfikacji poprawności porównamy efekt działania pętli z wartością zwracaną przez funkcję `sum()`).

```{r comment="", prompt=TRUE, collapse=TRUE}
x = 10:20
xSuma = 0
for (i in x) {
  xSuma = xSuma + i
}
xSuma
sum(x)
```

---

# Funkcje

Jeśli jakiś fragment kodu będziemy chcieli wykonywać wielokrotnie, użyteczne jest *opakowanie* go w funkcję. Pozwoli to zaoszczędzić nam wiele pisania (albo kopiowania), uczyni nasz kod bez porównania bardziej przejrzystym i mniej podatnym na błędy. Podzas tego kursu będziemy zajmować się pisaniem jedynie bardzo prostych funkcji, nie martwiąc się ani ich dokumentowaniem, ani czynieniem ich odpornymi na potencjalne próby niewłaściwego użycia.

Aby zdefiniować w R funkcję używa się składni:

```{r eval = FALSE, comment="", prompt=TRUE, collapse=TRUE}
nazwa_funkcji = function (argument1, argument2) {
  tu_jakiś_kod_który_robi_to_co_trzeba
  
  return(zwracanyObiekt)
}
```

Jeśli wykonamy w konsoli kod zawierający taką definicję funkcji, będziemy mogli jej potem używać w dalszej części naszego kodu.

Przykłady bardzo prostych funkcji:

```{r comment="", prompt=TRUE, collapse=TRUE}
# funkcja, która zwraca dokładnie to, co podano jej jako argument
ToSamo = function (x) {
  return(x)
}
ToSamo(1:5)

# "opakujmy" w funkcję naszą pętlę obliczającą sumę elementów wektora
SumujElementy = function(x) {
  xSuma = 0
  for (i in x) {
    xSuma = xSuma + i
  }
  return(xSuma)
}
SumujElementy(1:20)
sum(1:20)
```

---

#### Konwencja nazewnicza:

Pisząc kod dobrze jest stosować konwencje nazewnicze, czyli reguły nadawania obiektom nazw w zależności od ich rodzaju i przeznaczenia (np. [Google's R Style Guide](https://google.github.io/styleguide/Rguide.xml)). W szczególności dobrze jest móc łatwo stwierdzić na podstawie nazwy obiektu, czy jest on zmienną (np. wektorem) czy funkcją.

Niestety dobry zwyczaj stosowania konwencji nazewniczych jest wynalazkiem typowo informatycznym i w przeszłości raczej nie był praktykowany przez statystyków - efektem jest przerażający brak spójności w zakresie sposobu nazywania funkcji w ramach podstawowego zestawu pakietów R. Tworząc własny kod nie kultywujmy tej niechlubnej tradycji!

**Na naszych zajęciach będziemy stosować następującą konwencję nazywania obiektów:**

  1. Nie używamy polskich znaków.
  2. Nazwy wszystkich obiektów piszemy w konwencji *camel case*.
  3. Nazwy zmiennych zaczynamy małą literą, np. `x`, `mojaZmiena`, `innaMojaZmienna`.
  4. Nazwy funkcji zaczynamy wielką literą, np. `Funkcja`, `JakasFunkcja`, `JeszczeInnaFunkcja`.

---

# Konstrukcje warunkowe

Czasem chcemy aby w zależności od tego, jaką wartość logiczną przyjmie warunek określony w odniesieniu do pewnej zmiennej, wykonany został inny fragment kodu. Służy do tego konstrukcja `if ()`. Funkcja poniżej wykorzystuje tego typu konstrukcję, aby zwrócić orientacyjny stan jajka na podstawie liczby minut, przez które jajko było gotowane.

```{r comment="", prompt=TRUE, collapse=TRUE}
# funkcja, która zwraca dokładnie to, co podano jej jako argument
GotujeJajko = function(liczbaMinut) {
  if (liczbaMinut < 4) {
    stan = "niedogotowane"
  } else if (liczbaMinut < 6 ) {
    stan = "na miękko"
  } else if (liczbaMinut < 8.5) {
    stan = "półtwarde"
  } else {
    stan = "na twardo"
  }
  return(stan)
}
GotujeJajko(7)
```

# Parametry rozkładu zmiennej

Poniżej przypomnimy sobie definicje podstaowywch parametrów opisujących poziom oraz zróżnicowanie wartości zmienych statystycznych. Twoim zadaniem będzie zaimplementowanie obliczania tych parametrów w postaci funkcji. Możesz przy tym korzystać tylko z funkcji, które zostały wspomniane w tekście powyżej (w szczególności `sort()` i `length()`), pętli *for* oraz konstrukcji warunkowych *if-else*.

## Parametry poziomu wartości

### Minimum i maksimum

W bloku kodu poniżej zdefiniuj funkcję "Minimum", która zwróci najmniejszą wartość przyjmowaną przez elementy wektora, przekazanego jej jako argument. Wiersze poniżej pozwalają przetestować poprawność działania Twojej funkcji, porównując wyniki, jakie zwraca dla trzech przykładowych wektorów z wynikami zaimplementowanej w R funkcji `min()`.

```{r eval=FALSE, comment="", prompt=TRUE, collapse=TRUE}
Minimum = function(x) {
  # to jest miejsce na Twój kod
}
x = c(2, 3, 2, 2, 1)
y = c(97, 3, 4, 3, 3, 1)
z = c(10, 2, 4, 2, 1, 5)
Minimum(x) == min(x)  # 1
Minimum(y) == min(y)  # 1
Minimum(z) == min(z)  # 1
```

W podobny sposób zdefiniuj funkcję "Maksimum".

```{r eval=FALSE, comment="", prompt=TRUE, collapse=TRUE}
Maksimum = function(x) {
  # to jest miejsce na Twój kod
}
Maksimum(x) == max(x)  #  3
Maksimum(y) == max(y)  # 97
Maksimum(z) == max(z)  # 10
```

### Średnia arytmetyczna

Średnią arytmetyczną możemy obliczyć sumując wartości elementów wektora i następnie dzieląc uzyskaną sumę przez liczbę elementów. Zaimplementuj ten sposób obliczania średniej w funkcji o nazwie "Srednia".

```{r eval=FALSE, comment="", prompt=TRUE, collapse=TRUE}
Srednia = function(x) {
  # to jest miejsce na Twój kod
}
Srednia(x) == mean(x)  #  2
Srednia(y) == mean(y)  # 18.5
Srednia(z) == mean(z)  #  4
```

### Mediana

Mediana to taka wartość, że co najmniej połowa analizowanych jednostek ma wartość nie wyższą od niej i jednocześnie co najmniej połowa analizowanych jednostek ma wartość nie mniejszą od niej. Okazuje się, że wartości spełniające ten dosyć skomplikowany warunek dosyć łatwo jest określić.

  - W sytuacji, gdy liczba analizowanych jednostek jest nieparzysta, jest to wartość, którą przyjmuje *środkowa* jednostka, jeśli ustawimy je w kolejności według wartości danej zmiennej.
  - W sytuacji, gdy liczba analizowanych jednostek jest parzysta, medianą jest każda wartość (liczba rzeczywista) z przedziału, którego granice wyznaczają wartości tych dwóch obserwacji, które, jeśli ustawimy je w kolejności według wartości danej zmiennej, stoją *obok środka*.
    - Oznacza to, że jeśli te dwie jednostki mają różne wartości analizowanej zmiennej, to wartości będących medianą jest nieskończenie wiele. W praktyce chcemy jednak zwykle wybrać jedną z nich - typowo stosowaną regułą takiego ujednoznacznienia jest zwracanie jako mediany średniej z wartości wyznaczających granice przedziału (taka reguła jest też zaimplementowana w dostęnej w R funkcji `median()`).
    
W bloku kodu poniżej zdefiniuj funkcję "Mediana" zwracającą wartość mediany zadanego wektora, wykorzystując opisane powyżej reguły (w tym sposób ustalenia jednej wartości, która zostanie zwrócona w sytuacji, gdy medianą rozkładu jest wiele wartości) i strukturę warunkową `if() {} else {}`.

```{r eval=FALSE, comment="", prompt=TRUE, collapse=TRUE}
Mediana = function(x) {
  # to jest miejsce na Twój kod
}
Mediana(x) == median(x)  # 2
Mediana(y) == median(y)  # 3
Mediana(z) == median(z)  # 3
```

## Parametry rozproszenia

### Rozstęp

Rozstęp to różnica pomiędzy maksimum a minimum. W bloku kodu poniżej zdefiniuj funkcję "Rozstęp", która wykorzystując napisane przez Ciebie wcześniej funkcje `Maksimum()` i `Minimum()` obliczy i zwróci wartość rozstępu dla wektora przekazanego jej jako argument.

```{r eval=FALSE, comment="", prompt=TRUE, collapse=TRUE}
Rozstep = function(x) {
  # to jest miejsce na Twój kod
}
Rozstep(x) ==  2
Rozstep(y) == 96
Rozstep(z) ==  9
```

### Wariancja i odchylenie standardowe

Wariancja i odchylenie standardowe to najczęściej wykorzystywane parametry opisujące zróżnicowanir wartości zmiennych mierzonych na skalach przedziałowych (lub mocniejszych). Odgrywają też centralną rolę w wielu technikach analizy zależności pomiędzy zmiennymi (analiza wariancji, korelacja liniowa, regresja). Wariancję obliczamy jako średnią kwadratów różnic pomiędzy wartością zmiennej dla danej jednostki obserwacji a średnią danego rozkładu.

Odchylenie standardowe to pierwiastek kwadratowy z wariancji. Posługiwanie się nim jest o tyle użyteczne, że jest ono wyrażone w tej samej jednostce, co mierzona zmienna (wariancja jest mianowana w jednostce mierzonej zmiennej podniesinej do kwadratu).

Wykorzystując zdefiniowaną wcześniej przez siebie funkcje `Srednia()` zaimplementuj poniżej funkcję "Wariancja" zwracającą wartość wariancji dla wektora podanego jako jej argument. Następnie, wykorzystując ją zdefiniuj też funkcję "OdchylenieStandardowe".

Uwaga! Typowo dostępne w programach (i ogólniej bibliotekach) statystycznych funkcje służące obliczaniu wariancji zwracają nie opisany powyżej parametr opisowy, ale nieobciążony estymator wariancji populacyjnej obliczany przy założeniu, że zadane przez nas wartości są prostą próbą losową! Tak też zachowują się dostępne w R funkcje `var()` i `sd()`. Stąd aby wykorzystać je do weryfikacji poprawności działania naszej funkcji, musimy wcześniej przekształcić zwracane przez nie wyniki.

```{r eval=FALSE, comment="", prompt=TRUE, collapse=TRUE}
Wariancja = function(x) {
  # to jest miejsce na Twój kod
}
Wariancja(x) == (var(x) * (length(x) - 1) / length(x))  #    0.4
Wariancja(y) == (var(y) * (length(y) - 1) / length(y))  # 1233.25
Wariancja(z) == (var(z) * (length(z) - 1) / length(z))  #    9

OdchylenieStandardowe = function(x) {
  # to jest miejsce na Twój kod
}
```

### Współczynnik zmienności

W przypadku niektórych zmiennych (dokładnie: tych mierzonych na skalach ilorazowych) bardziej użyteczną praktycznie miarą zróżnicowania jest współczynnik zmienności, którego wartość otzrymujemy dzieląc odchylenia standardowe przez średnią danego rozkładu. W efekcie uzyskujemy współczynnik niemianowany (bez jednostki), którego wartości można porównywać nawet pomiędzy zmiennymi mierzonymi w różnych jednostkach. Jednakże aby obliczanie współczynnika zmienności miało sens, mierzona zmienna musi być mierzona na skali olorazowej i nie może przyjmować wartości ujemnych.

Zaimplementuj poniżej funkcję "WspolczynnikZmiennosci" zwracającą wartość współczynnika zmieności dla wektora podanego jako jej argument. Wykorzystaj zdefiniowane wcześniej przez siebie funkcje `Srednia()` i `OdchylenieStandardowe()`.

```{r eval=FALSE, comment="", prompt=TRUE, collapse=TRUE}
WspolczynnikZmiennosci = function(x) {
  # to jest miejsce na Twój kod
}
round(WspolczynnikZmiennosci(x), 6) == 0.353553
round(WspolczynnikZmiennosci(y), 6) == 2.079431
round(WspolczynnikZmiennosci(z), 6) == 0.821584
```

### Odchylenia przeciętne (od mediany)

Odchylenie przeciętne (od mediany) obliczane jest jako średnia modułów różnic pomiędzy wartością zmiennej dla danej jednostki obserwacji a medianą. Zaimplementuj poniżej funkcję "OdchyleniePrzecietne" zwracającą wartość odchylenia przeciętnego dla wektora podanego jako jej argument. Wykorzystaj zdefiniowaną wcześniej przez siebie funkcję `Srednia()`.

```{r eval=FALSE, comment="", prompt=TRUE, collapse=TRUE}
OdchyleniePrzecietne = function(x) {
  # to jest miejsce na Twój kod
}
OdchyleniePrzecietne(x) == 0.4
OdchyleniePrzecietne(y) == (16 + 1/6)
OdchyleniePrzecietne(z) == (2 + 1/3)
```

# Na następne zajęcia

## Praca domowa

Jeśli w czasie zajęć nie udało Ci się zaimplementować wpostaci funkcji wszystkich opisanych wyżej parametrów, dokończ to w domu. **Plik *.Rmd zawierający skończone ćwiczenie prześlij na adres zoltakt@is.uw.edu.pl** (zrób to również, jeśli udało Ci się skończyć w trakcie zajęć).

## Do przeczytania na następne zajęcia

[G. Lissowski, J. Haman i M. Jasiński. (2011). Podstawy statystyki dla socjologów. Wyd. II poprawione. Warszawa: Wydawnictwo Naukowe SCHOLAR.](http://libra.ibuk.pl/book/145985) - Rozdział 2. (w serwisie IBUK Libra dostępna za pośrednictwem konta czytelnika BUW).
